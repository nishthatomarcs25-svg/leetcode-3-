1-class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<=0){
            return false;
        }
        while(n%2==0){
            n=n/2;
        }
        return n==1;
    }
}

2-class Solution {
    public boolean isPowerOfThree(int n) {
        if(n<=0){
            return false;
        }
        while(n%3==0){
            n=n/3;
        }
        return n==1;
    }
}

3-class Solution {
    public boolean isPowerOfFour(int n) {
        if(n<=0){
            return false;
        }
        while(n%4==0){
            n=n/4;
        }
        return n==1;
    }
}

4-class Solution {
    public int addDigits(int num) {
       while(num>=10){
        int sum=0;
       
       while(num>0){
        sum=sum+num%10;
        num=num/10;
       }
       num=sum;
       }
       return num;
    }
}


5-class Solution {
    public int trailingZeroes(int n) {
        int count=0;
        while(n>0){
            n=n/5;
            count=count+n;
        }
        return count;
    }
}

6-class Solution {
    public int[] countBits(int n) {
        int[] ans=new int[n+1];
        for(int i=0;i<=n;i++){
            ans[i]=ans[i/2]+(i%2);
        }
        return ans;
    }
}

7-class Solution {
    public boolean isUgly(int n) {
        if(n<=0){
            return false;
        }
        while(n%2==0){
            n=n/2;
        }
        while(n%3==0){
            n=n/3;
        }
        while(n%5==0){
            n=n/5;
        }
        return n==1;
    }
}

8-class Solution {
    public int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int pre1=2;
        int pre2=1;
        for(int i=3;i<=n;i++){
            int cur=pre1+pre2;
            pre2=pre1;
            pre1=cur;
        }
        return pre1;
    }
}

9-class Solution {
    public boolean isPerfectSquare(int num) {
        int root=(int) Math.sqrt(num);
        return root*root==num;
    }
}

10-class Solution {
    public int findComplement(int num) {
        int mask=0;
        int temp=num;
        while(temp!=0){
            mask=(mask<<1)|1;
          temp>>=1;
        }
        return num^mask;
    }
}

11-class Solution {
    public int hammingDistance(int x, int y) {
      int count=0;
      for(int i=0;i<32;i++){
        if((x&1)!=(y&1))
        count++;
      
      x=x>>>1;
      y=y>>>1;
      }
      return count;
    }
}

